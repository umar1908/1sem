
LESSON_2
size_t:
int a[Size];
std::size_t n;
****************************
std::cerr<<""- поток ошибок

enum // разобраться #################################################

Выделение памяти/указатели:
  int* pi=new int;
  double* pd=new double[100];
  delete pi;
  delete[] pd;

Двумерный динамический массив N*M:
  Создание
    int** arr;
    arr=new int*[N];
    for (size_t i = 0; i < N; i++) {
      arr[i]=new int[M];
    }
  Очистка
    for (size_t i = 0; i < N; i++) {
      delete [] arr[i];
    delete [] arr;
    }
  arr=nullptr //нулевой указатель. Ошибка при попытке разименовать
  Ссылки
  int m;
  int &a =m //ссылка на m
  void f1(const int* n){
    //body
  }
  f1(&m);

  void f2(int &n){ //n будет ссылкой на переданный аргумент
    //body
  }
  f2(m)
***********************************
Строки
  #include <string>
  string str -пустая строка;
  string str("Hello World");
    Операции
    str1+str2 // склейка двух строк (Конкатенация)
    str.find() // разобраться ##############################################
************************************
Векторы
#inclde <vector>

vector<int> v(100); //Инициализация
v[19]=90;
v.push_back(45);???
for (int elem: v){
  cout<<elem;
}
v.erase() //Удаление векторов
vector<vector<int>> v(100) //Двумерный вектор
*********************************************
LESSON_3
ВОПРОС
double data[2][3];
data- double**
передача двумерного массива???
что такое диапазонна форма

**********************************************
Функции и лямбды:
(условие)?(если истина):(если ложно) // тернарный оператор

// inline функции
inline  int sum(int a,int b){
  return a+b;
}
// означает что под функции не нужно выделять стековый фрейм , а код функции
// нужно просто подставить в код. (рекомендация для компилятора)
********************************************
// модификатор static
int name(/* arguments */) {
  static int n=0;
  return 0;
}
// переменная становится статической и сохраняет свое значение при разных вызовах функции
*******************************************
// Параметры по умолчанию
int name(int n=10) {

  return 0;
}
// Если вызвать такую функцию без аргументов, то будет использование дефолтного значения
*********************************************
// Перегрузка
// Не будет ошибки компилирования, если функции с одинаковым именеи будут иметь
// аргументы разных типов
// Компилятор по передаваемым значениям сам выберет нужную функцию
********************************************
// Указатели на функции
T1 name(T2) {
  /* code */
  return 0;
}
T1 (*p)(T2); // указатель на произвольную функцию типа T1 с возвращаемым
// значением типа Т2
f=name эквивалентно f=&name
f(T2) //вызов функции name c параметрами Т2
*******************************************
// Лямюда выражение
auto lambda=[](<аргументы>)-> <возвращаемый тип>{
  <code>
  return ...
}
// указателю на функцию lambda присвоили лямбда функцию
// в функции без аргументов () можно опустить

#include <algoritm>
for_each(begin(v),end(v),func); //применение функции func для каждого элемента в диапазоне begin(v) end(v)
// устарел

count_if(begin(v),end(v),func);
*****************************************
// [] в lambda функциях передает в lambda функцию значение/ссылку из кода выше
[= ,&x] // захватить все кроме х по значениею а x по ссылке
[&, x] //захватить все кроме x по ссылке, а х по значениею
****************************************
// Макросы
#define MAX(x,y) (x>y)?(x):(y)\
  <code>;

MAX(5,3)---> (5>3)?(5):(3)
// Полезные макросы
__FILE__
__LINE__
__FUNC__

#include <cassert>
assert(n>10) // рушит программу при невыполнении условия


// Условная компиляция
// для ограничения платформозависимого кода
#ifdef __WIN32
  //<code>
#elif


***************************************
LESSON 4
// Структуры

struct Person;// объявление структуры.

struct Person{
  Person(string, int); //объявление конструктора
  Person();// объявление конструктор по умолчанию (перегрузка конструктора)
  ~Person(); // обявление деструктора
    name="default name";
    age=<default age>;
  }
  string name="Default name";// инициализвция по умолчанию
  int age=<default age>;
};


//определение конструктора
Person::Person(string _name, int age): name(_name),age(age){ //инициализация полей
  <code>
}

 // определение конструктора по умолчанию
Person::Person(): name("default name"),age(<default age>){
  <code>
}
// Определение деструткора
Person::~Person(){
  <code>
}


Person Max("name",int); // создание объектра типа Person
Person Default // создание объектра по умолчани. Скобки не нужны.
Person Max={'name', age}; // агригатная инициализацияь


Person employee[N];
Person* ptr = new Person; // выделение памяти под структуру
ptr->name="BOB"; //обращение к полям структуры через указатель
**************************************************************
// Битовые поля, Объединения, перечисления
// Перечисления
enum Colours {Red, Green, Blue};
Colours col=Red;
**************************************************************
LESSON 5
// Классы
// I) Инкапсуляция - объединение данных и алгосов в цельную сущность
// II) Наследование
// III)Полиморфизм
// III*) Абстракция
class Point(){
  public:

    double get_x() const{ //аксессор геттр const исользуется для того, чтобы запретить функции изменять поля класса
       return x;
    }
    void set_x(double x){ //аксессор сетттр
      this.x=x;
    }

  private:
    friend Point sum(const Point&, const Point&) //объявление друга класса. Такая функция,будет иметь доступ к приватным полям класса
    double x,y;

  protected:
};
#include <stdlib>
atof(<str>) //перегонка из str в float
atoy(<str>) //перегонка из str в int
// вызов конструктора
Point d{12,56} //uniform
Point b={112,234} // агригатный

************************************************
class MyInt{
  private:
    int n;
  public:
    MyInt(int _n):n(_n){};
    void print(){cout<<"n= "<<n;};

};

Myint i=6 //приведение типа int к типу Myint с помощью конструктора
// чтобы запретить неявное преобразование типов можно использовать explicit перед именем конструктора
explicit Myint();
MyInt()=delete // запретить создание конструктора по умолчанию

****************************************************
// перегрузка опреаторов

Point operator+(<arguments>){ //перегрузка опреатора сложения
  <code>
}
// эту функцию нужно либо добавлять в друзья к классу, либо делать эту
// функцию членом класс. Тогда первый операнд не нужен

// перегрузка cout

ostream& operator<<(ostream& os, const Point& p){
  os<<<text>;
  return os;
}
// Обязательно добавить эту функцию в друзья к Point

********************************************************
// статический член класса
private:
  static int counter;

int Point::counter=0; //инициализация

static func() //статическая функцияя общая для всего класса. Не имеет указателя this
Point::func() //вызов функции
*********************************************************
// Структура заголовочного файла
#ifndef A_H // защита от подключений
#define A_H
<code>
#endif

// аналогично:
#pragma once

******************************
LESSON_6
// КОПРИРОВАНИЕ
// Shallow copy
// Deep copy
// семантика копирования
Class A{
  A(const A&)//конструктор копирования
};

A a=b //тут будет использоваться конструктор копироваия

// delete для того чтобы запретить создавать реализации по умолчанию
// default для явного указания по-умолчанию
Class A{
  A(const A&)=delete
  A()=delete
  A& operator=(const A&)=delete // оператор присваивания должен возвращать то, куда копировал
  // для создания цепочки присваниваний
};
*****************************************************
// Семантика перемещения
// lvalue могут стоять слева от знака равно &
// rvalue могут стоять справа от равно &&
// характеристики объекта:
//идентифицируемость (glvalue)-i
// перемещаемость (rvaus)-m
lvalue(i и !m), xvalue(i и m)  - gvalue
xvalue(i и m), prvalue (!i и m) - rvalue

T& на любое не const lvalue
const T& на любое выражение
T&& на не const xvalue и pvalue
const T&& на все кроме lvalue
#include<utility>
move(<lvalue>)->rvalue

void exchange(string &str, string &str2){
  string temp=move(str1);
  str1=move(str2);
  str2=move(temp);
}

class A{
  A(A&&);//конструктор перемещения
  A& operator=(A&&); //опреатор перемещения
};

A::A(A&& rhs):

**************************************************
LESSON_7
vector<int> foo(const vector<int>& v){ //если оставить const, то a не изменится,
  // а если убрать, то изменится
  vector<int> a=move(v);
  return a;
}
int main(){
  vector<int> a{1,2,3,4,5};
  vector<int> b=foo(a);
  for(auto elem : b)
    cout<<elem<<endl;
    for(auto elem : a)
      cout<<elem<<endl;


*******************************************************
// Наследование. Иерархия классов
// Композиция
class Car{
  Engine en;
  Wheels wh[4]
};
//Агрегация
vector<Student&> students;
// Ассоциация -два назависимых, но взаимодействующих класса
//Зависимость (внутри себя использует элементы другого класса. Например cout)
// Обобщения
class A{
  //код класса А
};

//защищенное наследование
class B:A{
  //описание новых методов класса В, которыйх нет в классу А
  void foo();
public:
  B():A(){}; //Вызов конструктора А (не обязательно)
  ~B();
  void foo() override; //перекрытие метода foo override используется чтобы обязательно требовать переопределение функции
};
B.Animal::foo() //вызов функции foo из Animal
*******************************
//protected члены класса доступны только для методов класса и его потоммкой
class B: public A //открытое наследование (public->public, protected->pretected, private->private)
class B:private A// закрытое наследование (public->private, protected->private, private->недосьупный)
********************************************
 /* Уакзатель/ ссылка на базовый класс может указывать на производный класс
 Однако такой указатель не будет знать о собственных методах производного класса
 в классе родителе можно создавать virtual методы. Тогда указатель на родитель,
 указывающий на производный класс сможет обращаться к актуальной версии метода. (динамический полиморфизм)
 Если в классе объявлена хотя бы одна виртуальная функция, то деструктор тоже НУЖНО делать виртуальным

 */

 virtual void foo()=0;//чисто виртуальная функция
 // Класс в котором есть чисто виртуальная функция являеся абстрактным.
 // У абстрактного класса не может быть объектов
 *****************************************************************
 // Критерий Лисков
 x - объект класса Х
 p(x) -утверждение справедливое для любого х
 y - экземпляр класса Y наследника класса Х
 p(y) - 1
***********************************************
 class Cat: virtual public Animal{};
 class Dog: virtual public Animal{};
 class CatDog: Cat,Dog {};
 // тут virtual означает, что компилятор будет отслеживать, чтобы в потомках была только одна сущность Aninal
 ********************************************
 // классы содержащте только объявления методов чисто виртуальных методов называются интерфейсными классами
 // IWalker , IFlier...
********************************************
A* pan=dynamic_cast<B*>(&duck1);
// dynamic_cast используется чтобы дать доступ к методам наследника
***********************************************************************************
LESSON_8
// как в родительком классе создать объект дочернего класса?
// как запретитьь дочрнему классу использовать метод родиительского
// уонструктор дочернего класса не имеет доступа к protected членам родительского
**********************************************************************************
// Предупреждение ошибок
// 1)if-else
// 2)assert(n>0 && "string")
// 3)exit() terminate(), abort()
//Обработка ошибок
// коды возврата
// в функций передать лог ошибок по ссылке
//errno
//exceptions:
try{
  throw 1;
}
catch(int n){
  cout<<"Error N"<<n;
}

// класс для обработки ошибки днления на ноль
class DivisionByZeroExeption{
public:
  string what()const{
    return "Деление на ноль";
  }
}

void f(){
  int a=1;
  int b=0;
  if (b==0){
    throw DivisionByZeroExeption()
  }
  a/b;
}

try{
  f();
}
catch(const DivisionByZeroExeption&){
  // классы ошибок
#include <stdexcept>
  std::exception
  std::range_error
  std::logic_error
  std::bad_alloc
  std::bad_cast
  std::runtime_error


catch(...){ //ловит вообще любое исключение

}

void foo() noexcept;

Child::Child(): try{Base()}{

}
catch{

}

// Гарантия безопасности исключений:
// базовые гарантии :
// 1)инвариант класса
// 2)утечки ресурсов
// строгая гарантия:
// 1)после обработки исключения программа должна вернуться к изначальному состоянию (транзакционное поведение)
// отсутствие исключений:
********************************************************************************
// Паттерны проектирование
/*
пораждающие паттерны
структурные паттерны  (как модифицировать код, построить под свои нужны)
паттерны поведения
*/
class Singleton{
private:
  //закрыть конструктор и всю семантику перемещения
public:
  // static функция которая имеет в себе static экземпляр класса и возвращает его
};

// фабрика объектов

********************************************************************************
LESSON_9
//шаблоны
template <typename T, typename P>
T MAX(T a, P b){
  <code>
}
MAX<int,double>() //явное указание типов. Можно и без <>.

// Явная специализация шаблона
template<>
std::string MAX(std::string a,std::string b){
  return <code>
}

// приоритет отдается нешаблонной функции

// шаблоны классов
template <typename T=int, size_t sz_=128> //параметри по умолчанию
class A Array{
  T arr_[sz_];
public:
  T& operator[](size_t);
  const T& operator[](size_t) const;
};


template<typename T,size_t sz_>
T& Array<T,sz_>::operator[](size_t){
  <code>
}

Array arr<int,100>;
**********************************************************
как устроена uniform инициализация
компилирует шаблонные функции только при надобности

**********************************************************
// Умные указатели

#include <memory>
unique_ptr<Item>=make_unique<Item>(<параметры конструктора>)

shared_ptr<> //разделяемый указатель
auto item1=make_shared<Item>(<параметры констурктора>);.
shared_ptr<Item> item2=item1;

weak_ptr //слабый указатель - не учитывается в одсчете ссылок. Нельзя разыменовать
weak_ptr.lock() //разблокировать слыбый указатель
******************************************************************
// вариативные шаблоны
template<typename T, typename ... Args>
void print(T arg, Args ... args){
  // в Args будут типы данных, а в args сами данные
  cout<<arg;
  print(args...);
}

sizeof... -//длина пакета

template<typename...Args>
auto sum (Args...args){
  return (args+...); //args1+(args2+(args3+...)) право-ассоциативная скобка
}

******************************************************************
#include <type_traits>
SFINAE
*****************************************************************
//идеальная/прямая передача

******************************************************************
CRTP
UB undefined behaviour
n++ + n++
DRY  Dont repeat yourself
arr[1]=1;
arr[2]=2;
...
arr[5]=1;
